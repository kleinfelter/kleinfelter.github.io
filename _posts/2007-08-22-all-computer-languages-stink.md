---
title: All Computer Languages Stink
excerpt: "<p>All computer languages stink.  Some stink less than others. </p><p>It
  is a predictable pattern:</p><ol><li>I meet a new language.</li><li>I become infatuated
  with it.</li><li>I become disenchanted with it.</li></ol><p>I think I have reasonable
  expectations.  A language (and/or its development environment) should be able to:</p>"
layout: post
created: 1187809874
---

<p>All computer languages stink.  Some stink less than others. </p><p>It is a predictable pattern:</p><ol><li>I meet a new language.</li><li>I become infatuated with it.</li><li>I become disenchanted with it.</li></ol><p>I think I have reasonable expectations.  A language (and/or its development environment) should be able to:</p><ol><li>Use a Windows COM/ActiveX/OLE object via dynamic dispatch.Â  Visual Basic version 5 is the gold standandard, against which others will be compared.  </li><li>Call a routine written in C (static linked and dynamic or shared-library).</li><li>Parse an XML tree containing thousands of complex records in a few seconds.</li><li>Provide list comprehensions.</li><li>Support functional programming (including tail recursion optimization).<br /></li><li>Have a first-rate debugger. At a minimum, I want single click (or keyed-in command) to set a breakpoint, run-to-breakpoint, step-into and step-over, view content of a variable. </li><li>Support working at a high level of abstraction. (i.e. Be highly expressive.)</li><li>Serve dynamic web pages from data in any one of the popular SQL databases.</li><li>Run on Win32 and Linux.</li><li>Support code editing during a debug session to the level provided by Visual Basic 5.<br /></li></ol><p>What I don&#39;t like about:</p><ol><li>Erlang - they retired the interface to OLE/COM/ActiveX (Comet).  I use Windows (in addition to other platforms).  You can get Comet to work if you don&#39;t mind tinkering with the code to support the revised native interface. They say that its type system prevents errors. What I see is that, in order to get any real work done, you end up passing lists of tuples around, and those lists get interpreted on-the-fly, leading to typos in atom names not getting resolved until runtime.  The development environment is pretty rudimentary; Erlide, Erlyweb, and Emacs; only Emacs supports debugging (via Distel) and I don&#39;t need to get &quot;Emacs pinky.&quot;</li><li>Ruby - beautiful language; slow execution; threading doesn&#39;t actually run parallel due to global interpreter lock; you really <u>must</u> do test-driven development, because it is really hard to write bug-free code with almost nothing checked at compile-time.  Also, error messages tend to give the last line in the file as the source of the error, without regard for where the syntax error really happened.  (Is this an artifact of having such flexible syntax?)  I&#39;m not too enthused about investing a lot of effort in becoming expert in a language that depends upon one man for its definition.</li><li>Python - Comparable to Ruby in power; the infrastructure is more mature than Ruby.  In principle, I like indentation better than &quot;end&quot; or &quot;}&quot; for marking the end of a block because it is more succinct;  in practice, I&#39;m constantly nervous that a tab character snuck into my code, or that something 83 lines earlier got indented by 5 spaces instead of 4.  (You know, I&#39;d like an editor that converts leading spaces into 4-column tabs; the oposite of what most editors do, in converting tabs into spaces.  That way I could be sure that I didn&#39;t accidentally get 3 or 5 spaces when I meant 4.)  While I have nothing against Guido personally (never having met the guy), when I read his pronouncements about Python, I do hear the Dictator in BDFL (Benign Dictator For Life).  Contrast this with Matz ruminations, which are pretty hard to get upset over.  (&quot;Do it this way, the correct way,&quot; versus, &quot;Do it the way that that brings you joy.&quot; I&#39;m not too enthused about investing a lot of effort in becoming expert in a language that depends upon one man for its definition, although Google might hold things together if Guido were in a car wreck.</li><li>SmallTalk -- Remind me why I didn&#39;t like SmallTalk?  Was it the whole image thing?  Would that be OK if I just drank the Kool-aid? Avi seems like a pretty smart guy. (I&#39;ve not met him, but we did exchange email, and Seaside is pretty slick -- even if it did take me a while to wrap my mind around it.)  Small syntax is good.  I still love Pascal&#39;s one-page syntax chart.  (Pascal from Jensen and Wirth&#39;s second report -- not Delphi or Free Pascal.)  It is almost as slow as Ruby.  It doesn&#39;t appear to make use of multiple-core CPUs.<br /></li></ol><br />

<hr width="100%" size="2" />
<hr width="100%" size="2" /><br />

<ul><li>Free Pascal</li><li>OCaml<ul><li>COM via http://tech.motion-twin.com/ocamole.html</li><li>OCSIGEN provides web application framework<br /></li></ul></li><li>Lua<ul><li>COM via LuaCOM</li><li>Web Application framework is Kepler (Xavante helps deploy in Windows)<br /></li></ul></li><li>GHC<ul><li>COM via HaskellScript</li><li>Testing (ala test-o-matic) via QuickCheck</li><li>HAppS provides web application framework</li><li>I built HAppS. It doesn&#39;t look like Haskell has a package manager, so I had to fetch dependencies based on error messags from &quot;runhaskell Setup.hs configure&quot;.  The good news is that configure/(fetch/build-fetched/install-fetched/)repeat/build/install, worked smoothly, and the resulting system ran a HelloWorld app without any errors or surprises.  </li></ul></li><li>Scala(JVM)<ul><li>COM via Java via JACOB    </li></ul></li><li>Java<ul><li>COM via JACOB</li></ul></li><li>Python<ul><li>pywin32</li></ul></li><li>Ruby<ul><li>win32</li></ul></li><li>Groovy<ul><li>COM via Scriptom (layered on top of JACOB)<br /></li></ul></li><li>C++<ul><li>COM native access<br /></li></ul></li><li>SBCL<ul><li>COM is apparently unavailable<br /></li></ul></li><li>Erlang<ul><li>COM via Comet (which is obsolete and doesn&#39;t work with current Erlarg without rework)</li></ul></li></ul>